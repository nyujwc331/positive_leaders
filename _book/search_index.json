[
["index.html", "The DSS Innovation style guide Ji won Chang 1 Welcome", " The DSS Innovation style guide Ji won Chang 1 Welcome This is the R coding standard for Data Science Services (DSS) production level data science projects and applications. It is derived from Google’s R Style Guide and Hadley Wickham’s The tidyverse style guide. This style guide makes our R code readable, shareable, and reproducible. This is intended to guide code written prospectively, not a guide by which you should evaluate previous code. "],
["project.html", "2 Projects", " 2 Projects All scripts for DSS production level projects and applications must be in a project following the {golem} framework for building production-grade Shiny Applications. golex ├── DESCRIPTION ├── NAMESPACE ├── R │ ├── app_server.R │ ├── app_ui.R │ └── run_app.R ├── dev │ ├── 01_start.R │ ├── 02_dev.R │ ├── 03_deploy.R │ └── run_dev.R ├── inst │ └── app │ └── www │ ├── favicon.ico │ └── plop.js └── man └── run_app.Rd "],
["syntax.html", "3 Syntax 3.1 File Names 3.2 Object names 3.3 Function definition and calls 3.4 Pipes 3.5 ggplot2", " 3 Syntax Production level data science projects and applications can be developed by multiple Data Scientists. The following are syntax rules to ease R code collaboration and handoff. 3.1 File Names File names should be meaningful and end in .R. Avoid using special characters in file names - stick with numbers, letters, -, and _. If a file contains a single function, give the file the same name as the function. If a file contains multiple related functions, give it a concise, but evocative name. # Good fit_models.R utility_functions.R # Bad fit models.R foo.r stuff.r If files should be run in a particular order, prefix them with numbers. If it seems likely you’ll have more than 10 files, left pad with zero: 00_download.R 01_explore.R ... 09_model.R 10_visualize.R If you later realize that you’ve missed some steps, it’s tempting to use 02a, 02b, etc. However, I think it’s generally better to bite the bullet and rename all files. Pay attention to capitalization, since you, or some of your collaborators, might be using an operating system with a case-insensitive file system (e.g., Microsoft Windows or OS X) which can lead to problems with (case-sensitive) revision control systems. Prefer file names that are all lower case, and never have names that differ only in their capitalization. 3.2 Object names Variable and function names should use only lowercase letters, numbers, and _. Use underscores (_) (so called snake case) to separate words within a name. Generally, variable names should be nouns and function names should be verbs. Strive for names that are concise and meaningful (this is not easy!). # Good df_day_one # df for dataframe df_day_1 # Bad DayOne dayone Object names, especially for Shiny applications should start with the type of object. This code predates the style guide, which is why it does not follow the snake case convention. # Good dfSum$visitLog &lt;- log10(dfSum$visitCnt) checkboxGroupInput(&quot;chkExclusionDiag&quot;, label = tags$h5(&quot;Excluded: &quot;), choices = c(), inline = TRUE)) output$ospTable &lt;- DT::renderDataTable({ df &lt;- dfOsp() df %&lt;&gt;% dplyr::select(proposalId, description, piName, awardDt, sponsorName) df %&lt;&gt;% dplyr::mutate( proposalId = proper(proposalId), description = proper(description), piName = proper(piName), awardDt = as.Date(awardDt), sponsorName = proper(sponsorName) ) 3.3 Function definition and calls Function definitions should first list arguments without default values, followed by those with default values. For functions to be be compatible with dplyr, the first argument must be a data frame or the object that is operated on. In both function definitions and function calls, multiple arguments per line are allowed; line breaks are only allowed between assignments. # Good predict_ctr &lt;- function(query, property, num_days, showplot = TRUE) # Bad predict_ctr &lt;- function(query, property, num_days, showplot = TRUE) 3.4 Pipes %&gt;% should always have a space before it, and should usually be followed by a new line. After the first step, each line should be indented by two spaces. This structure makes it easier to add new steps (or rearrange existing steps) and harder to overlook a step. # Good iris %&gt;% group_by(Species) %&gt;% summarize_if(is.numeric, mean) %&gt;% ungroup() %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) # Bad iris %&gt;% group_by(Species) %&gt;% summarize_all(mean) %&gt;% ungroup %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) 3.5 ggplot2 Styling suggestions for + used to separate ggplot2 layers are very similar to those for %&gt;% in pipelines. + should always have a space before it, and should be followed by a new line. This is true even if your plot has only two layers. After the first step, each line should be indented by two spaces. If you are creating a ggplot off of a dplyr pipeline, there should only be one level of indentation. # Good iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% ggplot(aes(x = Sepal.Width, y = Sepal.Length)) + geom_point() # Bad iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% ggplot(aes(x = Sepal.Width, y = Sepal.Length)) + geom_point() # Bad iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% ggplot(aes(x = Sepal.Width, y = Sepal.Length)) + geom_point() If the arguments to a ggplot2 layer don’t all fit on one line, put each argument on its own line and indent: # Good ggplot(aes(x = Sepal.Width, y = Sepal.Length, color = Species)) + geom_point() + labs( x = &quot;Sepal width, in cm&quot;, y = &quot;Sepal length, in cm&quot;, title = &quot;Sepal length vs. width of irises&quot; ) # Bad ggplot(aes(x = Sepal.Width, y = Sepal.Length, color = Species)) + geom_point() + labs(x = &quot;Sepal width, in cm&quot;, y = &quot;Sepal length, in cm&quot;, title = &quot;Sepal length vs. width of irises&quot;) ggplot2 allows you to do data manipulation, such as filtering or slicing, within the dataargument. Avoid this, and instead do the data manipulation in a pipeline before starting plotting. # Good iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% ggplot(aes(x = Sepal.Width, y = Sepal.Length)) + geom_point() # Bad ggplot(filter(iris, Species == &quot;setosa&quot;), aes(x = Sepal.Width, y = Sepal.Length)) + geom_point() "],
["documentation.html", "4 Documentation 4.1 Inline comments 4.2 Function documentation 4.3 README 4.4 Walkthrough", " 4 Documentation A data science project or application will not be considered production level without inline comments, function documentation, and a README. Shiny applications will require also require a walkthrough. Keep in mind that the product that you are making is an app, not documentation. Keep documentation lean. 4.1 Inline comments In code, use comments to explain the “why” not the “what” or “how”. # Good # Objects like data frames are treated as leaves x &lt;- map_if(x, is_bare_list, recurse) # Bad # Recurse only with bare lists x &lt;- map_if(x, is_bare_list, recurse) 4.2 Function documentation Functions should contain a comments section immediately below the function definition line. These comments should consist of a one-sentence description of the function; a list of the function’s arguments, denoted by Args:, with a description of each (including the data type); and a description of the return value, denoted by Returns:. The comments should be descriptive enough that a caller can use the function without reading any of the function’s code. CalculateSampleCovariance &lt;- function(x, y, verbose = TRUE) { # Computes the sample covariance between two vectors. # # Args: # x: One of two vectors whose sample covariance is to be calculated. # y: The other vector. x and y must have the same length, greater than one, # with no missing values. # verbose: If TRUE, prints sample covariance; if not, not. Default is TRUE. # # Returns: # The sample covariance between x and y. n &lt;- length(x) # Error handling if (n &lt;= 1 || n != length(y)) { stop(&quot;Arguments x and y have invalid lengths: &quot;, length(x), &quot; and &quot;, length(y), &quot;.&quot;) } if (TRUE %in% is.na(x) || TRUE %in% is.na(y)) { stop(&quot; Arguments x and y must not have missing values.&quot;) } covariance &lt;- var(x, y) if (verbose) cat(&quot;Covariance = &quot;, round(covariance, 4), &quot;.\\n&quot;, sep = &quot;&quot;) return(covariance) } 4.3 README There is no guide for the types of information to include in a README, especially if you also have created a vignette. Below are examples of the types of documentation you could include. 4.4 Walkthrough All production-grade Shiny applications must have a walkthrough created using {rintrojs}. library(rintrojs) library(shiny) # Define UI for application that draws a histogram ui &lt;- shinyUI(fluidPage( introjsUI(), # Application title introBox( titlePanel(&quot;Old Faithful Geyser Data&quot;), data.step = 1, data.intro = &quot;This is the title panel&quot; ), # Sidebar with a slider input for number of bins sidebarLayout(sidebarPanel( introBox( introBox( sliderInput( &quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30 ), data.step = 3, data.intro = &quot;This is a slider&quot;, data.hint = &quot;You can slide me&quot; ), introBox( actionButton(&quot;help&quot;, &quot;Press for instructions&quot;), data.step = 4, data.intro = &quot;This is a button&quot;, data.hint = &quot;You can press me&quot; ), data.step = 2, data.intro = &quot;This is the sidebar. Look how intro elements can nest&quot; ) ), # Show a plot of the generated distribution mainPanel( introBox( plotOutput(&quot;distPlot&quot;), data.step = 5, data.intro = &quot;This is the main plot&quot; ) )) )) # Define server logic required to draw a histogram server &lt;- shinyServer(function(input, output, session) { # initiate hints on startup with custom button and event hintjs(session, options = list(&quot;hintButtonLabel&quot;=&quot;Hope this hint was helpful&quot;), events = list(&quot;onhintclose&quot;=I(&#39;alert(&quot;Wasn\\&#39;t that hint helpful&quot;)&#39;))) output$distPlot &lt;- renderPlot({ # generate bins based on input$bins from ui.R x &lt;- faithful[, 2] bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the specified number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) # start introjs when button is pressed with custom options and events observeEvent(input$help, introjs(session, options = list(&quot;nextLabel&quot;=&quot;Onwards and Upwards&quot;, &quot;prevLabel&quot;=&quot;Did you forget something?&quot;, &quot;skipLabel&quot;=&quot;Don&#39;t be a quitter&quot;), events = list(&quot;oncomplete&quot;=I(&#39;alert(&quot;Glad that is over&quot;)&#39;))) ) }) # Run the application shinyApp(ui = ui, server = server) "],
["test.html", "5 Testing 5.1 Shiny applications 5.2 Production level models", " 5 Testing When automated unit testing is appropriate, the following packages are recommended. 5.1 Shiny applications All production-grade Shiny applications must use {shinytest} to run automated tests. Shinytest uses snapshot-based testing strategy. The first time it runs a set of tests for an application, it performs some scripted interactions with the app and takes one or more snapshots of the application’s state. These snapshots are saved to disk so that future runs of the tests can compare their results to them. library(devtools) install_github(&quot;rstudio/shinytest&quot;) library(shinytest) # Launch the target app (replace with the correct path) recordTest(&quot;path/to/app&quot;) # Run tests testApp(&quot;myshinyapp&quot;, &quot;mytest&quot;) 5.2 Production level models Some production level data science projects will need formal automated testing. R studio recommends using the {testthat} package. "],
["manage.html", "6 Project management 6.1 Time 6.2 Issues 6.3 Commit messages", " 6 Project management Data science projects and applications will be managed and tracked using Jira and GitLab. 6.1 Time Time spent on specific projects and applications, PTO, and meetings will be tracked in Jira. 6.2 Issues Tasks will be tracked in GitLab by creating an issue and assigning that issue to a person and project. 6.3 Commit messages Progress updates will be documented through commit messages. Follow standard git commit message advice. The first line is the subject, and should summarise the changes in the commit in under 50 characters. If additional details are required, add a blank line, and then provide explanation and context in paragraph format. "]
]
